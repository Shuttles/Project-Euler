/*************************************************************************
	> File Name: 31.0.cpp
	> Author: 
	> Mail: 
	> Created Time: 2019年08月11日 星期日 19时43分32秒
 ************************************************************************/
 //状态定义：f(k, n)表示用前k种钱币拼凑n元
 //正向递推：公式怎么写就怎么写程序,公式:f(k, n) = f(k - 1, n) + f(k, n - w[k]);
//这种方法用递归，如果不加记忆化。时间是0.022s，
//加了记忆化之后，时间是0.001s
#include <iostream>
#include <cstdio>
int w[9] = {0, 1, 2, 5, 10, 20, 50, 100, 200};
int f(int k, int n);
int keep[9][205];

int main() {
    printf("%d\n", f(8, 200));
    return 0;
}

int f(int k, int n) {
    if (n == 0) return 1;                 /*前k种钱币拼凑0便士，只有一种方法，就是什么都不要*/
    if (n < 0) return 0;
    if (k == 1) return 1;                 /*前三行是边界条件，仔细一想和正向递推的for循环的边界是一样的！*/
    if (keep[k][n]) return keep[k][n];
    int temp = f(k - 1, n) + f(k, n - w[k]);
    //if ((k > 0 && k < 9) && (n >= 0 && n <= 200)) /*泽哥写的时候加了这行，但是现在发现用不上！！！*/
        keep[k][n] = temp;
    return temp;
}
